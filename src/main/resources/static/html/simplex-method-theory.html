<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Симплекс-метод. Теория</title>
    <link rel="stylesheet" href="../css/styles.css">
    <link rel="stylesheet" href="../katex/katex.min.css">
</head>
<body>
<header class="header">
    <a href="/" class="logo">
        <div class="logo-text">LPCalc</div>
    </a>
    <nav class="nav">
        <a href="/graphical" class="nav-item">Графический метод</a>
        <a href="/simplex" class="nav-item">Симплекс метод</a>
        <a href="/theory" class="nav-item active">Теория</a>
    </nav>
</header>
<div id="content-container" class="theory-content-container">
    <h1>Симплекс-метод. Теория</h1>
    <p>
        Симплекс-метод — алгоритм решения оптимизационной задачи линейного программирования путём перебора вершин
        выпуклого многогранника в многомерном пространстве. Алгоритм является универсальным методом, которым можно
        решить любую задачу линейного программирования. </p>
    <p class="subtitle">Добавление балансовых переменных</p>
    <div class="theory-container">
        <div>
            <p>Прежде чем приступить к решению задачи с помощью симплекс-метода, нужно привести все ограничения к
                равенствам, то есть к каноническому виду. На первом этапе все неравенства вида "больше или равно"
                умножаются на -1, преобразуя их в ограничения "меньше или равно". </p>
            <br>
            <p>После этого к каждому неравенству "меньше или равно" добавляют новую переменную, называемую
                дополнительной (или балансовой), с коэффициентом 1. Такие переменные в итоговом ответе не
                рассматриваются, но они необходимы для преобразования системы неравенств в систему равенств и позволяют
                сразу получить базисное (опорное) решение, с которого начинается работа симплекс-метода. </p>
            <br>
            <p>Экономический смысл дополнительных (балансовых) переменных заключается в том, что они отражают
                неиспользованные ресурсы или остатки между доступными и фактически задействованными ресурсами в рамках
                ограничений.</p>
        </div>
        <div class="theory-container-image">
            <img src="../img/slack-variables.png">
        </div>
    </div>
    <p class="subtitle">Поиск первоначального базиса</p>
    <div class="theory-container">
        <div>
            <p>После того как задача приведена к каноническому виду, необходимо найти начальный базис для формирования
                первого опорного решения. Если в процессе приведения были добавлены балансовые переменные, то они
                становятся базисными.</p>
            <br>
            <p>Иначе необходимо выделить среди коэффициентов ограничений столбец, который участвует в формировании
                единичной матрицы в заданной строке (например, если требуется определить вторую базисную переменную, то
                необходимо искать столбец, в котором второе число равно 1, а остальные равны нулю). Если такой столбец
                найден, то переменная, соответствующая этому столбцу, становится базисной.</p>
            <br>
            <p>В противном случае можно поискать столбец, в котором все значения кроме числа в заданной строке равны
                нулю, и, если он будет найден, то разделить все значения строки на число, стоящее на пересечении этих
                строки и столбца, тем самым образовав столбец, участвующий в формировании единичной матрицы.</p>
            <br>
            <p>Если такой столбец отсутствует, то для формирования базиса необходимо применить исключение Гаусса для
                первого ненулевого столбца, который ещё не является базисным. Для этого вся строка делится на элемент в
                найденном столбце, а из остальных строк вычитается полученная строка, разделённая на значение, стоящее в
                этом же столбце. После этой операции все значения вне данной строки будут обнулены, и столбец можно
                будет считать базисным.</p>
        </div>
    </div>
    <p class="subtitle">Построение симплекс таблицы</p>
    <div class="theory-container">
        <div>
            <p>После того как базис сформирован, нужно построить начальную симплекс-таблицу. </p>
            <br>
            <p>В первой строке записываются коэффициенты $C_i$ целевой функции (для дополнительных переменных это
                коэффициенты равны нулю). Данные коэффициенты означают прибыль при производстве $1$ единицы ресурса.</p>
            <p>Крайний левый столбец - базисные переменные. В контексте задачи линейного программирования это
                производимые ресурсы.</p>
            <p>Нижний столбец - оценки ($\Delta$). Они показывают влияние на целевую функцию производства 1 доп. ед.
                продукта.</p>
            <p>Крайний правый столбец ($b$) - свободные коэффициенты. Количество запасов сырья/количество произведенной
                продукции.</p>
            <p>Коэффициенты в центральной части таблицы – количество затрат сырья на единицу произведенной
                продукции.</p>
            <p>Крайний правый нижний элемент таблицы – текущее значение целевой функции.</p>
        </div>
        <div class="theory-container-image">
            <img src="../img/table-deltas.png">
        </div>
    </div>
    <p class="subtitle">Исключение свободных коэффициентов</p>
    <p>После приведения к каноническому виду или после алгебраических преобразований при формировании базиса некоторые
        из свободных коэффициентов $(b_i)$ могли стать отрицательными, что не позволяет перейти к дальнейшим
        вычислениям. Чтобы избавиться от отрицательных значений $b$ необходимо:</p>
    <ul>
        <li>Найти строку, в которой находится максимальное по модулю значение $b$. Пусть это будет строка $i$;</li>
        <li>Найти максимальный по модулю элемент среди отрицательных в этой строке. Пусть он находится в столбце $j$;</li>
        <li>Строку $i$ разделить на элемент, стоящий на пересечении $i$-ой строки и $j$-го столбца;</li>
        <li>Из каждой оставшейся строки $k$ вычесть строку $i$, умноженную на элемент строки $k$ и столбца $j$;</li>
        <li>Переменную, соответствующую найденному столбцу $j$, сделать базисной (добавить в базис вместо переменной,
            находящейся в строке $i$).
        </li>
    </ul>
    <p>Этот шаг необходимо повторять до тех пор, пока все отрицательные $b$ не станут положительными или в строке не
        останется отрицательных элементов. Если строка с максимальным по модулю $b_i$ не содержит отрицательных
        элементов, то такая задача не имеет решений и на этом алгоритм заканчивает свою работу. В противном случае все
        $b_i$ положительны и алгоритм переходит к следующему этапу — расчёту дельт.</p>
    <p class="subtitle">Расчёт дельт $(\Delta)$</p>
    <p>Дельты — это параметры, на основании которых проверяется оптимальность текущего решения и улучшается функция. Они
        рассчитываются для каждой из переменных ограничений и записываются последней строкой таблицы.</p>
    <p>Для расчёта дельт используется следующая формула: $\Delta_i = c_{e1} \cdot a_{1i} + c_{e2} \cdot a_{2i} + ... +
        c_{em} \cdot a_{mi} - c_i$.</p>
    <p>Проще говоря, чтобы вычислить дельту по заданной $i$-ой переменной, нужно перемножить коэффициенты условий в
        $i$-ом столбце на коэффициенты целевой функции при соответствующих базисных переменных, сложить эти произведения
        и вычесть из полученной суммы коэффициент целевой функции столбца $i$.</p>
    <p class="subtitle">Проверка плана на оптимальность</p>
    <div>
        <p>После того как дельты рассчитаны, необходимо проверить оптимальность текущего плана. Критерий оптимальности
            формулируется следующим образом:</p>
        <br>
        <p><b>При максимизации функции:</b> текущее решение считается оптимальным, если в таблице отсутствуют
            отрицательные дельты.</p>
        <p><b>При минимизации функции:</b> текущее решение считается оптимальным, если в таблице отсутствуют
            положительные дельты.</p>
        <br>
        <p>Если текущий план оптимален, то алгоритм завершает свою работу. Значениям переменных соответствуют значения столбца свободных коэффициентов $b$. Если свободной переменной нет в базисе, то её значение считается нулевым. Значение целевой функции, принимаемой на данном наборе, находится в строке с дельтами в том же столбце. Если какое-либо из значений столбца $b$ отрицательно, то решения задачи не существует.</p>
    </div>
    <p class="subtitle">Переход к более оптимальному решению</p>
    <div class="theory-container">
        <div>
            <p>Если текущий план оказался не оптимальным, то алгоритм ищет столбец с наименьшей (с наибольшей, если ищется минимум) дельтой. После чего вычисляются симплекс-отношения $Q$. Для этого значения свободных коэффициентов делятся на ненулевые коэффициенты из найденного столбца. Если результат деления получается отрицательным, то такие отношение игнорируются.</p>
            <br>
            <p>Среди найденных симплекс-отношений ищется строка, в которой находится симплекс-отношение с наименьшим значением. Если таких отношений нет, то алгоритм останавливает свою работу, так как целевая функция не ограничена и решения не существует.</p>
            <br>
            <p>В противном случае строка с наименьшим отношением считается разрешающей и, аналогично избавлению от отрицательных свободных коэффициентов, делится на разрешающий элемент, расположенный в найденных столбце и строке, и из остальных строк вычитается найденная строка, разделённая на значения, стоящие в этом же столбце соответствующей строки. Переменная, стоящая в разрешающем столбце заменяет базисную переменную, находящуюся в найденной строке.</p>
            <br>
            <p>После этого вычисляются новые дельты и проверяется новый план. Так продолжается до тех пор пока не будет выполнен критерий оптимальности плана или не будет установлено, что решение не существует.</p>
        </div>
        <div class="theory-container-image">
            <img src="../img/pivot-table.png">
        </div>
    </div>
    <h1>Метод искусственного базиса</h1>
    <p>Очень часто при решении задачи линейной оптимизации бывает довольно сложно выполнять алгебраические преобразования над коэффициентами ограничений для поиска начального базиса. Для упрощения вычислений существует альтернативный метод решения, называемый <b>методом искусственного базиса</b>. Его суть заключается в том, что вместо того, чтобы искать базис среди имеющихся основных и дополнительных переменных, ввести так называемые искусственные переменные, которые сформируют начальный базис.</p>
    <p class="subtitle">Подготовительный этап</p>
    <p>Аналогично базовому симплекс-методу для всех ограничений с неравенством вводятся дополнительные переменные, причём для ограничений с $/geq$ они берутся с коэффициентом $-1$, а для ограничений с $\leq$ с коэффициентом $1$. Ограничения с равенством остаются без изменений. Если свободный коэффициент какого-либо из ограничений меньше нуля, то такое ограничение умножается на -1 (знак неравенства при этом меняется на противоположный). После этого приступают к поиску базиса.</p>
    <p class="subtitle">Поиск начального базиса</p>
    <div class="theory-container">
        <div>
            <p>Для того, чтобы сформировать начальный базис в первую очередь можно поискать столбец, у которого одно значение равно единице, а все значения остальные значения равны нулю, и сделать соответствующую переменную базисной для этой строки. Однако такое случается довольно редко, поэтому проще сразу перейти к следующему пункту. Для всех ограничений, не имеющих базисной переменной, добавляем искусственную переменную с коэффициентом $1$. В целевую функцию добавляем эту же переменную с коэффициентов $-M$, если ищется максимум или с коэффициентом $M$, если ищется минимум. $M$ всего лишь является очень большим числом.</p>
            <br>
            <p>Далее, алгоритм работает как базовый симплекс-метод, за исключением того, что если в оптимальном решении в базисе присутствуют искусственные переменные - решения нет.</p>
        </div>
        <div class="theory-container-image">
            <img src="../img/table-bigM.png">
        </div>
    </div>

</div>
</body>
<script defer src="../katex/katex.min.js"></script>
<script defer src="../katex/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
<script src="../js/katex.js"></script>
</html>